// ignore_for_file: prefer_final_fields

import 'package:cloture/model/cart_item.dart';
import 'package:cloture/services/cart_service.dart';
import 'package:cloture/services/auth_service.dart';
import 'package:cloture/services/connectivity_service.dart';
import 'package:cloture/utils/logger.dart';
import 'package:flutter/foundation.dart';

class CartController extends ChangeNotifier {
  CartController({
    required CartService cartService,
    required AuthService authService,
    ConnectivityService? connectivityService,
  }) : _cartService = cartService,
       _authService = authService,
       _connectivityService = connectivityService ?? ConnectivityService();

  final CartService _cartService;
  final AuthService _authService;
  final ConnectivityService _connectivityService;

  List<CartItem> _cartItems = [];
  bool _isLoading = false;
  bool _isSyncing = false;

  List<CartItem> get cartItems => _cartItems;
  bool get isLoading => _isLoading;
  bool get isSyncing => _isSyncing;

  // Calculated properties
  int get totalItems => _cartItems.fold(0, (sum, item) => sum + item.quantity);
  double get subtotal =>
      _cartItems.fold(0.0, (sum, item) => sum + (item.price * item.quantity));
  double get tax => subtotal * 0.0; // 0% tax for now
  double get shippingCost => 8.00;
  double get total => subtotal + shippingCost + tax;

  /// Load cart from Firestore (or cache if offline)
  Future<void> loadCart() async {
    final user = _authService.currentUser;
    if (user == null) {
      _cartItems = [];
      notifyListeners();
      return;
    }

    _isLoading = true;
    notifyListeners();

    try {
      // Try to sync cached cart to Firestore if online
      final isConnected = await _connectivityService.isConnected();
      if (isConnected) {
        await _cartService.syncCartToFirestore(user.uid);
      }

      // Load cart (from Firestore if online, cache if offline)
      _cartItems = await _cartService.getCart(user.uid);
    } catch (e) {
      AppLogger.error('Error loading cart', e);
      _cartItems = [];
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Listen to cart changes in real-time
  void startListening() {
    final user = _authService.currentUser;
    if (user == null) return;

    _cartService
        .getCartStream(user.uid)
        .listen(
          (items) {
            _cartItems = items;
            notifyListeners();
            // Update cache
            _updateCache();
          },
          onError: (e) {
            AppLogger.error('Error listening to cart', e);
          },
        );
  }

  /// Add item to cart
  Future<bool> addToCart({
    required String productId,
    required String name,
    required String imageUrl,
    required double price,
    required String size,
    required String color,
    required int quantity,
  }) async {
    final user = _authService.currentUser;
    if (user == null) return false;

    final item = CartItem(
      id: '', // Will be auto-generated by Firestore
      productId: productId,
      name: name,
      imageUrl: imageUrl,
      price: price,
      size: size,
      color: color,
      quantity: quantity,
      timestamp: DateTime.now(),
    );

    try {
      final success = await _cartService.addToCart(user.uid, item);
      if (success) {
        // Reload cart to get updated data
        await loadCart();
      }
      return success;
    } catch (e) {
      AppLogger.error('Error adding to cart', e);
      return false;
    }
  }

  /// Remove item from cart
  Future<bool> removeItem(String cartItemId) async {
    final user = _authService.currentUser;
    if (user == null) return false;

    try {
      final success = await _cartService.removeFromCart(user.uid, cartItemId);
      if (success) {
        // Optimistically update local state
        _cartItems.removeWhere((item) => item.id == cartItemId);
        notifyListeners();
        // Reload to sync
        await loadCart();
      }
      return success;
    } catch (e) {
      AppLogger.error('Error removing item', e);
      return false;
    }
  }

  /// Update item quantity
  Future<bool> updateQuantity(String cartItemId, int newQuantity) async {
    final user = _authService.currentUser;
    if (user == null) return false;

    try {
      final success = await _cartService.updateQuantity(
        user.uid,
        cartItemId,
        newQuantity,
      );
      if (success) {
        // Optimistically update local state
        final index = _cartItems.indexWhere((item) => item.id == cartItemId);
        if (index != -1) {
          if (newQuantity <= 0) {
            _cartItems.removeAt(index);
          } else {
            _cartItems[index] = _cartItems[index].copyWith(
              quantity: newQuantity,
            );
          }
          notifyListeners();
        }
        // Reload to sync
        await loadCart();
      }
      return success;
    } catch (e) {
      AppLogger.error('Error updating quantity', e);
      return false;
    }
  }

  /// Clear entire cart
  Future<bool> clearCart() async {
    final user = _authService.currentUser;
    if (user == null) return false;

    try {
      final success = await _cartService.clearCart(user.uid);
      if (success) {
        _cartItems = [];
        notifyListeners();
      }
      return success;
    } catch (e) {
      AppLogger.error('Error clearing cart', e);
      return false;
    }
  }

  /// Get cart item count (for badge)
  Future<int> getCartItemCount() async {
    final user = _authService.currentUser;
    if (user == null) return 0;

    try {
      return await _cartService.getCartItemCount(user.uid);
    } catch (e) {
      AppLogger.error('Error getting cart count', e);
      return totalItems; // Fallback to local count
    }
  }

  /// Update local cache
  Future<void> _updateCache() async {
    // Cache is updated automatically by CartService
    // This is just a placeholder for future enhancements
  }

  @override
  void dispose() {
    _connectivityService.dispose();
    super.dispose();
  }
}
