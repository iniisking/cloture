import 'package:cloture/model/favorite_item.dart';
import 'package:cloture/services/favorites_service.dart';
import 'package:cloture/services/auth_service.dart';
import 'package:cloture/services/connectivity_service.dart';
import 'package:flutter/foundation.dart';

class FavoritesController extends ChangeNotifier {
  FavoritesController({
    required FavoritesService favoritesService,
    required AuthService authService,
    ConnectivityService? connectivityService,
  })  : _favoritesService = favoritesService,
        _authService = authService,
        _connectivityService = connectivityService ?? ConnectivityService();

  final FavoritesService _favoritesService;
  final AuthService _authService;
  final ConnectivityService _connectivityService;

  List<FavoriteItem> _favoriteItems = [];
  bool _isLoading = false;
  bool _isSyncing = false;

  List<FavoriteItem> get favoriteItems => _favoriteItems;
  bool get isLoading => _isLoading;
  bool get isSyncing => _isSyncing;
  int get favoritesCount => _favoriteItems.length;

  /// Load favorites from Firestore (or cache if offline)
  Future<void> loadFavorites() async {
    final user = _authService.currentUser;
    if (user == null) {
      _favoriteItems = [];
      notifyListeners();
      return;
    }

    _isLoading = true;
    notifyListeners();

    try {
      // Try to sync cached favorites to Firestore if online
      final isConnected = await _connectivityService.isConnected();
      if (isConnected) {
        await _favoritesService.syncFavoritesToFirestore(user.uid);
      }

      // Load favorites (from Firestore if online, cache if offline)
      _favoriteItems = await _favoritesService.getFavorites(user.uid);
    } catch (e) {
      print('Error loading favorites: $e');
      _favoriteItems = [];
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Listen to favorites changes in real-time
  void startListening() {
    final user = _authService.currentUser;
    if (user == null) return;

    _favoritesService.getFavoritesStream(user.uid).listen(
      (items) {
        _favoriteItems = items;
        notifyListeners();
        // Update cache
        _updateCache();
      },
      onError: (e) {
        print('Error listening to favorites: $e');
      },
    );
  }

  /// Add product to favorites
  Future<bool> addToFavorites({
    required String productId,
    required String name,
    required String imageUrl,
    required double price,
  }) async {
    final user = _authService.currentUser;
    if (user == null) return false;

    final item = FavoriteItem(
      id: '', // Will be auto-generated by Firestore
      productId: productId,
      name: name,
      imageUrl: imageUrl,
      price: price,
      timestamp: DateTime.now(),
    );

    try {
      final success = await _favoritesService.addToFavorites(user.uid, item);
      if (success) {
        // Reload favorites to get updated data
        await loadFavorites();
      }
      return success;
    } catch (e) {
      print('Error adding to favorites: $e');
      return false;
    }
  }

  /// Remove product from favorites
  Future<bool> removeFavorite(String favoriteItemId) async {
    final user = _authService.currentUser;
    if (user == null) return false;

    try {
      final success = await _favoritesService.removeFromFavorites(
        user.uid,
        favoriteItemId,
      );
      if (success) {
        // Optimistically update local state
        _favoriteItems.removeWhere((item) => item.id == favoriteItemId);
        notifyListeners();
        // Reload to sync
        await loadFavorites();
      }
      return success;
    } catch (e) {
      print('Error removing favorite: $e');
      return false;
    }
  }

  /// Remove product from favorites by productId
  Future<bool> removeByProductId(String productId) async {
    final user = _authService.currentUser;
    if (user == null) return false;

    try {
      final success = await _favoritesService.removeByProductId(
        user.uid,
        productId,
      );
      if (success) {
        // Optimistically update local state
        _favoriteItems.removeWhere((item) => item.productId == productId);
        notifyListeners();
        // Reload to sync
        await loadFavorites();
      }
      return success;
    } catch (e) {
      print('Error removing favorite by productId: $e');
      return false;
    }
  }

  /// Toggle favorite status (add if not favorite, remove if favorite)
  Future<bool> toggleFavorite({
    required String productId,
    required String name,
    required String imageUrl,
    required double price,
  }) async {
    final isFavorite = await isProductFavorite(productId);
    
    if (isFavorite) {
      return await removeByProductId(productId);
    } else {
      return await addToFavorites(
        productId: productId,
        name: name,
        imageUrl: imageUrl,
        price: price,
      );
    }
  }

  /// Check if product is in favorites
  Future<bool> isProductFavorite(String productId) async {
    final user = _authService.currentUser;
    if (user == null) return false;

    try {
      // First check local state
      if (_favoriteItems.any((item) => item.productId == productId)) {
        return true;
      }
      
      // Then check Firestore/cache
      return await _favoritesService.isFavorite(user.uid, productId);
    } catch (e) {
      print('Error checking if favorite: $e');
      return false;
    }
  }

  /// Clear all favorites
  Future<bool> clearFavorites() async {
    final user = _authService.currentUser;
    if (user == null) return false;

    try {
      final success = await _favoritesService.clearFavorites(user.uid);
      if (success) {
        _favoriteItems = [];
        notifyListeners();
      }
      return success;
    } catch (e) {
      print('Error clearing favorites: $e');
      return false;
    }
  }

  /// Update local cache
  Future<void> _updateCache() async {
    // Cache is updated automatically by FavoritesService
    // This is just a placeholder for future enhancements
  }

  @override
  void dispose() {
    _connectivityService.dispose();
    super.dispose();
  }
}
